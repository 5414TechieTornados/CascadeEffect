#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     IRRight,        sensorI2CCustom)
#pragma config(Sensor, S3,     gyro,           sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     right,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     topCollector,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     bottomCollector, tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    topGate,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    tube,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    auto4,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-irseeker-v2.h"
#include "JoystickDriver.c"
#include "drivers/hitechnic-gyro.h"

//Robot directional info
float xCoor = -1;
float yCoor = -1;
int direction = 0;
float heading = 0.0;

//directions
int north = 0;
int east = 1;
int south = 2;
int west = 3;

//string version of directions
string forward = "forward";
string backwards = "backwards";
string rightDirection = "right";
string leftDirection = "left";

//movement information
float maxSpeed = 60;
float turnSpeed = 78;
float tolerance = 0;
float blockDistance = 12;
float leftTurnDistance = 10;
float turnDistance = 11.4;

const float TOP_GATE_UP = 140;
const float TOP_GATE_DOWN = 255;
const float SPIN_UP_TIME = 1100;
const float SPIN_UP_TIME_HIGHER = 1600;
const float TURN_TIME = 1.0;
const float RIGHT_TURN_TIME = 1.1;
const float TUBE_SERVO_UP = 60;
const float TUBE_SERVO_DOWN = 113;


const float buffer = 5.0;

void initializeRobot()
{

  // Place code here to initialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	servoTarget[topGate] = TOP_GATE_DOWN;
	servoTarget[tube] = TUBE_SERVO_UP;

  	return;
}

void startSpin(bool up){
	ClearTimer(T1);
	if(up){
		motor[lift] = -100;
	}
	else{
		motor[lift] = -00;
	}
}

bool checkSpinTimer(){
	if(time1(T1) > SPIN_UP_TIME){
		motor[lift] = 0;
		return true;
	}
	else
		return false;
}

float convertInches(float inches){
	return (1120/6) * inches;
}

/*Basic right turn
*/
void turnRight(float speed){
	motor[left] = speed;
	motor[right] = -speed;
}

/*Basic left turn
*/
void turnLeft(float speed){
	motor[left] = -speed;
	motor[right] = speed;
}

/*Stopping the motors
*/
void stopMotors(){
	motor[left] = 0;
	motor[right] = 0;
}

void raiseLift(float time){
	motor[lift] = -100;
	wait1Msec(time);
	motor[lift] = 0;
}

void score(){
	servoTarget(topGate) = TOP_GATE_UP;
	wait10Msec(250);
}


void driveRobot(float distance, float speed, string direction){
		//reset encoder values
	nMotorEncoder[right] = 0;
	nMotorEncoder[left] = 0;

	wait10Msec(1);

	float target = convertInches(distance);

	//setting the encoder target
	//nMotorEncoderTarget[right] = target;
	//nMotorEncoderTarget[left] = target;
	//blocks used to set correct motor speeds
	if(forward == direction){
		motor[right] = speed + 1;
		motor[left] = speed;
	}
	else if(backwards == direction){
		motor[right] = -speed - 1;
		motor[left] = -speed;
	}
	else if(rightDirection == direction){
		motor[right] = -speed - 1;
		motor[left] = speed;
	}
	else if(leftDirection == direction){
		motor[right] = speed + 1;
		motor[left] = -speed;
	}
	ClearTimer(T2);
		//Move the robot until encoder target is reached
	while(abs(nMotorEncoder[right]) < target){
	//while(nMotorRunState[left] != runStateIdle){

		checkSpinTimer();
		nxtDisplayTextLine(1, "target: %d", target);
		nxtDisplayTextLine(2, "Right: %d", nMotorEncoder[right]);
		nxtDisplayTextLine(3, "Left: %d", nMotorEncoder[left]);
		if(abs(target - abs(nMotorEncoder[right])) < tolerance || abs(target - abs(nMotorEncoder[left])) < tolerance){
			break;
		}
		if(time1(T2) > 10000){
			motor[right] = 0;
			motor[left] = 0;
			raiseLift(SPIN_UP_TIME_HIGHER);
			score();
			while(true){
			}
		}
	}
	motor[right] = 0;
	motor[left] = 0;
}

/*The logic to use the gyroscope in a turn
*/
void gyroTurn(float target, float speed, bool direction){
	HTGYROstartCal(gyro);
	heading = 0.0;
	float currTime;
	float prevTime = nPgmTime;
	while (true)
	{
		checkSpinTimer();
		currTime = nPgmTime;
		//Our heading calculation logic
		heading += (abs((float)HTGYROreadRot(gyro))) * (currTime - prevTime) / 1000;
		prevTime = currTime;

		if(direction)
		{
			if(heading < (target - buffer))
			{
				turnRight(speed);
			//	nxtDisplayString(1,"gyro: %i",HTGYROreadRot(gyro));
			}
			else if(heading > (target + buffer))
			{
				turnLeft(speed);
			//	nxtDisplayString(1,"gyro: %i",HTGYROreadRot(gyro));
			}
			else if(heading <= (target + buffer) && heading >= (target - buffer))
			{
				stopMotors();
			//	wait1Msec(waitTime);
				return;
			}
		}
		else
		{
			if(heading < (target - buffer))
			{
				turnLeft(speed);
			//	nxtDisplayString(1,"gyro: %i",HTGYROreadRot(gyro));

			}
			else if(heading > (target + buffer))
			{
				turnRight(speed);
			//	nxtDisplayString(1,"gyro: %i",HTGYROreadRot(gyro));
			}
			else if(heading <= (target + buffer) && heading >= (target - buffer))
			{
				stopMotors();
			//	wait1Msec(waitTime);
				return;
			}
		}
	}
	checkSpinTimer();
}

void turnLeft(float distance){
	driveRobot(distance, turnSpeed, leftDirection);
}

void turnRight(float distance){
	driveRobot(distance, turnSpeed, rightDirection);
}

void driveOffRamp(){
	driveRobot(blockDistance * 5.1, 60, backwards);
	driveRobot(3, 20, backwards);
	servoTarget[tube] = TUBE_SERVO_DOWN;
	driveRobot(blockDistance, 60, forward);
	gyroTurn(45.0, turnSpeed, true);
	driveRobot(blockDistance + 13.5, 78, forward);
	gyroTurn(45.0, turnSpeed, false);
	driveRobot(blockDistance * 2, 78, forward);
	gyroTurn(40.0, turnSpeed, true);
	driveRobot(blockDistance/2, 60, forward);
	gyroTurn(160.0, turnSpeed, false);
	raiseLift(SPIN_UP_TIME);
	gyroTurn(10.0, 35, true);
	wait10Msec(300);
	score();
	driveRobot(blockDistance/2, 60, backwards);
	while(true){
	}
}

task main()
{
	initializeRobot();
	waitForStart();
	driveOffRamp();
}
