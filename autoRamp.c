#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     IRRight,        sensorI2CCustom)
#pragma config(Sensor, S3,     ,               sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     launcher,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     belts,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     left,          tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C2_2,     right,         tmotorTetrix, PIDControl, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     collector,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     lift,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    bottomGate,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    topGate,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    tube,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    auto4,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-irseeker-v2.h"
#include "JoystickDriver.c"

//Robot directional info
float xCoor = -1;
float yCoor = -1;
int direction = 0;

//directions
int north = 0;
int east = 1;
int south = 2;
int west = 3;

//string version of directions
string forward = "forward";
string backwards = "backwards";
string rightDirection = "right";
string leftDirection = "left";

//movement information
float maxSpeed = 60;
float turnSpeed = 50;
float tolerance = 0;
float blockDistance = 12;
float leftTurnDistance = 10;
float turnDistance = 11.4;

const float TOP_GATE_UP = 180;
const float TOP_GATE_DOWN = 60;
const float SPIN_UP_TIME = 6400;
const float TURN_TIME = 1.0;
const float RIGHT_TURN_TIME = 1.1;

//Bad points on the field
bool badPoint [7][7];

void initializeRobot()
{

  // Place code here to initialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	servoTarget[topGate] = TOP_GATE_DOWN;
	servoTarget[tube] = 255;

  	return;
}

void startSpin(bool up){
	ClearTimer(T1);
	if(up){
		motor[lift] = -100;
	}
	else{
		motor[lift] = -00;
	}
}

bool checkSpinTimer(){
	if(time1(T1) > SPIN_UP_TIME){
		motor[lift] = 0;
		return true;
	}
	else
		return false;
}

bool validPoint (int X, int Y){
	return badPoint[X][Y];
}

float convertInches(float inches){
	return (1120/6) * inches;
}

void driveRobot(float distance, float speed, string direction){
		//reset encoder values
	nMotorEncoder[right] = 0;
	nMotorEncoder[left] = 0;

	wait10Msec(100);

	float target = convertInches(distance);

	//setting the encoder target
	//nMotorEncoderTarget[right] = target;
	//nMotorEncoderTarget[left] = target;
	//blocks used to set correct motor speeds
	if(forward == direction){
		motor[right] = speed + 1;
		motor[left] = speed;
	}
	else if(backwards == direction){
		motor[right] = -speed - 1;
		motor[left] = -speed;
	}
	else if(rightDirection == direction){
		motor[right] = -speed - 1;
		motor[left] = speed;
	}
	else if(leftDirection == direction){
		motor[right] = speed + 1;
		motor[left] = -speed;
	}

		//Move the robot until encoder target is reached
	while(abs(nMotorEncoder[right]) < target){
	//while(nMotorRunState[left] != runStateIdle){

		checkSpinTimer();
		nxtDisplayTextLine(1, "target: %d", target);
		nxtDisplayTextLine(2, "Right: %d", nMotorEncoder[right]);
		nxtDisplayTextLine(3, "Left: %d", nMotorEncoder[left]);
		if(abs(target - abs(nMotorEncoder[right])) < tolerance || abs(target - abs(nMotorEncoder[left])) < tolerance){
			break;
		}
	}
	motor[right] = 0;
	motor[left] = 0;
}

void turnLeftTime(int full){

	motor[left] = -100;
	motor[right] = 100;
	if(full == 0){
		wait10Msec(100 * TURN_TIME);
	}
	else if(full == 1){
		wait10Msec(100 * (TURN_TIME/1.8));
	}
	else{
		wait10Msec(100 * (TURN_TIME * 1.2));
	}
	motor[left] = 0;
	motor[right] = 0;
}

void turnRightTime(int full){
	motor[left] = 100;
	motor[right] = -100;
		if(full == 0){
		wait10Msec(100 * RIGHT_TURN_TIME);
	}
	else{
		wait10Msec(100 * (RIGHT_TURN_TIME/1.8));
	}
	motor[left] = 0;
	motor[right] = 0;
}
void turnLeft(float distance){
	driveRobot(distance, turnSpeed, leftDirection);
}

void turnRight(float distance){
	driveRobot(distance, turnSpeed, rightDirection);
}


void driveOffRamp(){
	driveRobot(blockDistance * 5.1, 78, backwards);
	driveRobot(3, 35, backwards);
	servoTarget[tube] = 0;
	driveRobot(blockDistance, 78, forward);
	turnRight(turnDistance/1.8);
	driveRobot(blockDistance + 6.5, 78, forward);
	turnLeft(turnDistance / 2.15);
	driveRobot(blockDistance * 3.1, 78, forward);
	turnLeft(turnDistance + 2.8);
	motor[lift] = -100;
	wait10Msec(300);
	motor[lift] = 0;
	servoTarget(topGate) = TOP_GATE_UP;
	while(true){
	}
}

task main()
{
	initializeRobot();
	waitForStart();
	driveOffRamp();
}
