#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     IRRight,        sensorI2CCustom)
#pragma config(Sensor, S3,     ,               sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     launcher,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     belts,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     left,          tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C2_2,     right,         tmotorTetrix, PIDControl, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     collector,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     lift,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    bottomGate,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    topGate,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    tube,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    auto4,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-irseeker-v2.h"
#include "JoystickDriver.c"

//Robot directional info
float xCoor = -1;
float yCoor = -1;
int direction = 0;

//directions
int north = 0;
int east = 1;
int south = 2;
int west = 3;

//string version of directions
string forward = "forward";
string backwards = "backwards";
string rightDirection = "right";
string leftDirection = "left";

//movement information
float maxSpeed = 60;
float turnSpeed = 78;
float tolerance = 0;
float blockDistance = 12;
float leftTurnDistance = 10;
float turnDistance = 8.6;

const float TOP_GATE_UP = 180;
const float TOP_GATE_DOWN = 60;
const float SPIN_UP_TIME = 7;
const float TURN_TIME = 1.0;
const float RIGHT_TURN_TIME = 1.1;

//Bad points on the field
bool badPoint [7][7];

void initializeRobot()
{

  // Place code here to initialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	servoTarget[topGate] = TOP_GATE_DOWN;
	servoTarget[tube] = 255;

  	return;
}

bool validPoint (int X, int Y){
	return badPoint[X][Y];
}

float convertInches(float inches){
	return (1120/6) * inches;
}

void driveRobot(float distance, float speed, string direction){
		//reset encoder values
	nMotorEncoder[right] = 0;
	nMotorEncoder[left] = 0;

	wait10Msec(100);

	float target = convertInches(distance);

	//setting the encoder target
	//nMotorEncoderTarget[right] = target;
	//nMotorEncoderTarget[left] = target;
	//blocks used to set correct motor speeds
	if(forward == direction){
		motor[right] = speed + 1;
		motor[left] = speed;
	}
	else if(backwards == direction){
		motor[right] = -speed - 1;
		motor[left] = -speed;
	}
	else if(rightDirection == direction){
		motor[right] = -speed - 1;
		motor[left] = speed;
	}
	else if(leftDirection == direction){
		motor[right] = speed + 1;
		motor[left] = -speed;
	}

		//Move the robot until encoder target is reached
	while(abs(nMotorEncoder[right]) < target){
	//while(nMotorRunState[left] != runStateIdle){
		nxtDisplayTextLine(1, "target: %d", target);
		nxtDisplayTextLine(2, "Right: %d", nMotorEncoder[right]);
		nxtDisplayTextLine(3, "Left: %d", nMotorEncoder[left]);
		if(abs(target - abs(nMotorEncoder[right])) < tolerance || abs(target - abs(nMotorEncoder[left])) < tolerance){
			break;
		}
	}
	motor[right] = 0;
	motor[left] = 0;
}

void moveForward(float difference, bool coor, float speed){

	for(int i = 0; i < abs(difference); i++){
		if(direction == north || direction == east){
			if(coor){
				if(validPoint(xCoor + 1, yCoor)){
					xCoor++;
				}
			}
			else{
				if(validPoint(xCoor, yCoor + 1)){
					yCoor++;
				}
			}
		}
		else{
			if(coor){
				if(validPoint(xCoor - 1, yCoor)){
					xCoor--;
				}
			}
			else{
				if(validPoint(xCoor, yCoor - 1)){
					yCoor--;
				}
			}
		}

		//nxtDisplayString(0,"X: %i",xCoor);
		//nxtDisplayString(1,"Y: %i",yCoor);
		driveRobot(blockDistance, speed, forward);
	}
}

void turnLeftTime(int full){

	motor[left] = -100;
	motor[right] = 100;
	if(full == 0){
		wait10Msec(100 * TURN_TIME);
	}
	else if(full == 1){
		wait10Msec(100 * (TURN_TIME/1.8));
	}
	else{
		wait10Msec(100 * (TURN_TIME * 1.2));
	}
	motor[left] = 0;
	motor[right] = 0;
}

void turnRightTime(int full){
	motor[left] = 100;
	motor[right] = -100;
		if(full == 0){
		wait10Msec(100 * RIGHT_TURN_TIME);
	}
	else{
		wait10Msec(100 * (RIGHT_TURN_TIME/1.8));
	}
	motor[left] = 0;
	motor[right] = 0;
}
void turnLeft(){

	motor[left] = -100;
	motor[right] = 100;

		wait10Msec(100 * TURN_TIME);


		wait10Msec(100 * (TURN_TIME/2));

	motor[left] = 0;
	motor[right] = 0;

	//direction = ((direction - 1) + 4) % 4;
	//driveRobot(leftTurnDistance, turnSpeed, leftDirection);
	//nxtDisplayString(2,"D: %i",direction);
	//wait10Msec(100);
}

void turnRight(){
	motor[left] = 100;
	motor[right] = -100;
	wait10Msec(100 * RIGHT_TURN_TIME);
	motor[left] = 0;
	motor[right] = 0;
	//direction = ((direction + 1) + 4) % 4;
	//driveRobot(turnDistance, turnSpeed, rightDirection);
	//nxtDisplayString(2,"D: %i",direction);
	//wait10Msec(100);
}

void handleCoor(float newCoor, float speed, bool axis){
	float difference;

	if(axis){
		difference = newCoor - xCoor;
  }
	else{
 		difference = newCoor - yCoor;
	}
	if(difference != 0){
		//North Direction
		if(direction == north){
			//Positive
			if((difference/abs(difference)) == 1){
				//x axis
				if(axis){
					turnRight();
				}
				//y axis
				else{
				}
			}
			//Negative
			else{
				//x axis
				if(axis){
					turnLeft();
				}
				//y axis
				else{
					turnLeft();
					turnLeft();
				}
			}
		}
		//South Direction
		else if(direction == south){
			//Positive
			if((difference/abs(difference)) == 1){
				//x axis
				if(axis){
					turnLeft();
				}
				//y axis
				else{
					turnLeft();
					turnLeft();
				}
			}
			//Negative
			else{
				//x axis
				if(axis){
					turnRight();
				}
				//y axis
				else{
				}
			}
		}
		//East Direction
		else if(direction == east){
			//Positive
			if((difference/abs(difference)) == 1){
				//x axis
				if(axis){
			}
			//y axis
				else{
					turnLeft();
				}
			}
			//Negative
			else{
				//x axis
				if(axis){
					turnLeft();
					turnLeft();
				}
				//y axis
				else{
					turnRight();
				}
			}
		}
		//West Direction
		else if(direction == west){
			//Positive
			if((difference/abs(difference)) == 1){
				//x axis
				if(axis){
					turnLeft();
					turnLeft();
				}
				//y axis
				else{
					turnRight();
				}
			}
			//Negative
			else{
				//x axis
				if(axis){
				}
				//y axis
				else{
					turnLeft();
				}
			}
		}
		moveForward(difference, axis, speed);
	}
}

void scoreBall(){

	motor[lift] = -100;
	wait10Msec(100 * SPIN_UP_TIME);
	motor[lift] = 0;
	motor[left] = -35;
	motor[right] = -35;
	wait10Msec(55);
	motor[left] = 0;
	motor[right] = 0;

	wait10Msec(150);
	servoTarget(topGate) = TOP_GATE_UP;
	wait10Msec(250);
	motor[left] = 78;
	motor[right] = 78;
	wait10Msec(40);
}

void simulateRobot(float newXCoor, float newYCoor, float speed){
	if(speed != 0){
		handleCoor(newXCoor, speed, true);
		handleCoor(newYCoor, speed, false);
	}
	xCoor = newXCoor;
	yCoor = newYCoor;
	//nxtDisplayString(0,"X: %i",xCoor);
//	nxtDisplayString(1,"Y: %i",yCoor);
//	nxtDisplayString(2,"D: %i",direction);
//	nxtDisplayString(3,"Move done");
//	wait10Msec(500);
//	nxtDisplayClearTextLine(3);
}

void hitPeg(){
	turnRightTime(0);
	driveRobot(blockDistance/1.2, 78, backwards);
	turnLeftTime(2);
	driveRobot(4 * blockDistance, 78, backwards);

	motor[left] = 0;
	motor[right] = 0;
	motor[lift] = 100;
	wait10Msec(100 * (SPIN_UP_TIME - 2));
	motor[lift] = 0;
}

void firstPosition(){
	driveRobot(1.85 * blockDistance, 78, backwards);
	scoreBall();
	hitPeg();
}

void secondPosition(){
	driveRobot(blockDistance/2, 78, backwards);
	turnLeftTime(1);
	driveRobot(blockDistance * 1.8, 78, backwards);
	turnRight();
	scoreBall();
	hitPeg();
}

task main()
{
	initializeRobot();
	//waitForStart();
	badPoint[3][3] = false;
	badPoint[3][4] = false;
	badPoint[4][3] = false;
	badPoint[4][4] = false;
	badPoint[3][1] = false;
	badPoint[4][1] = false;

	tHTIRS2DSPMode _mode = DSP_1200;
	int seekerValue = -5;
	wait10Msec(50);

	while(true){
			seekerValue = HTIRS2readACDir(IRRight);
	nxtDisplayString(2,"IR: %i",seekerValue);
	}
	if(seekerValue > 4){
		firstPosition();
	}
	else if(seekerValue > 2){
		secondPosition();
	}
	while(true){
	}

	/*
	simulateRobot(4, 1, 0);
	simulateRobot(4, 2, maxSpeed);
	simulateRobot(2, 2, maxSpeed);
	simulateRobot(2, 4, maxSpeed);


	/*
	simulateRobot(2, 2, 0);
	simulateRobot(2, 5, 78);

	simluateRobot(3, 2, 100);
	simulateRobot(2, 2, 100);
	simulateRobot(4, 2, 100);
	simulateRobot(4, 4, 100);
	simulateRobot(4, 2, 100);
	simulateRobot(1, 5, 100);
	simulateRobot(3, 2, 100);
	simulateRobot(4, 2, 100);
	simulateRobot(2, 1, 100);
	simulateRobot(3, 3, 100);
	simulateRobot(3, 5, 100);
	simulateRobot(3, 3, 100);
	simulateRobot(3, 1, 100);
	simulateRobot(3, 5, 100);
	simulateRobot(4, 5, 100);
	simulateRobot(5, 5, 100);
	simulateRobot(4, 5, 100);
	*/
}
